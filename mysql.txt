1，主键 超键 候选键 外键
	主键：唯一完成表示的列，不能为null。
	超键：唯一识别元组的属性集，一个或多个属性都可作为一个超键，包含候选键和主键。
	候选键：没有冗余元素的最小超键。
	外键：存在另一个表的主键称为此表的外键。
2，数据库事务的四个特性 ACID
	原子性(Atomicity)：要么全部执行要么回滚。
	一致性(Correspondence)：事务执行前后，数据库完整性约束没被破坏。
	隔离性(Isolation)：同一时间只有一个请求用于同一数据。
	持久性(Durability)：事务结束后对数据库的更改持久的保存，不会回滚。
3，视图的作用、可以更改吗？
	视图是虚拟的表，只包含使用时动态检索数据的查询，不包含任何列或数据。
	视图可以简化复杂的sql操作，隐藏具体的细节，保护数据。使用与表相同的方式利用。
	视图不能被索引，也不能有关联的触发器或默认值。
	对未使用联结子查询分组聚集函数Distinct Union的视图可以更新，并且将对基表进行更新，但视图主要用于简化检索，保护数据，大部分视图不能被更新。
4，drop、delete、truncate
	（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
	（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。
	（3） 一般而言，drop > truncate > delete
	（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view
	（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。
	（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
	（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
	（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚
	（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。
	（10） Truncate table 表名 速度快,而且效率高,因为:truncate table 在功能上与不带 WHERE 子句的 DELETE语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
	（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。
	（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。
5，索引
	索引实现常用B树及其变种B+树。
	设置索引的代价：增加了数据库存储空间，插入修改要花费更多时间。
	一般来说，应该在这些列上创建索引：
	在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
	一般来说，不应该创建索引的的这些列具有下列特点：
	第一，对于那些在查询中很少使用或者参考的列不应该创建索引。第二，对于那些只有很少数据值的列也不应该增加索引。第三，对于那些定义为text,image和bit数据类型的列不应该增加索引。第四，当修改性能远远大于检索性能时，不应该创建索引。
	唯一索引：
	不允许其中任何两行具有相同索引值的索引。
	主键索引：
	在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。
	聚集索引：
	表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。聚集索引通常提供更快的数据访问速度。
	局部性原理：
	当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。
	(提高效率，减少磁盘IO，磁盘顺序读取的效率很高，不需要寻道，只需要很少的旋转时间预读的长度一般为页（page）的整倍数。)
	B-/+Tree索引的性能分析：
	每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
6，连接的种类
	外连接：
	左外连接：SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id;(重名字段重命名)
	右外连接：SELECT * FROM table1 RIGHT JOIN table2 ON table1.id = table2.id;
	完整外连接：SELECT * FROM table1 FULL JOIN table2 ON table1.id = table2.id;(返回左右连接的和)
	内连接：(join 或 inner join)只返回符合条件的table1和table2的列
	select * from table1 join table2 on table1.id=table2.id;
	交叉连接：(cross join)cross join后加条件只能用where,不能用on
	不带where条件的交叉连接产生笛卡尔积
	select * from table1 cross join table2 = select * from table1,table2
	select a.*,b.* from table1 a,table2 b where a.id=b.id = select * from table1 cross join table2 where table1.id=table2.id
7，数据库范式
	第一范式(1NF)
	第一范式就是无重复的列,不满足第一范式（1NF）的数据库就不是关系数据库.
	第二范式(2NF)
	第二范式就是非主属性非部分依赖于主关键字。
	第三范式(3NF)
	第三范式就是属性不依赖于其它非主属性，消除冗余。
8，数据库优化
	1，SQL优化
		1）应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
		2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
		select id from t where num is null
		可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
		select id from t where num=0
		3）很多时候用 exists 代替 in 是一个好的选择
		4）用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤
	2，索引优化
	3，数据库优化
		1）范式优化：消除冗余，节省空间。
		2）反范式优化：适当增加冗余，减少join。
		3）拆分表：分区数据在物理上分割开。
		4）垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上 水平拆分： 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺
9，存储过程和触发器
	触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。
	触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。
	触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。







